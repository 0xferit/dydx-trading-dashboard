<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dYdX Analytics</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0A0A0A;
            --bg-secondary: #121212;
            --bg-elevated: #1E1E1E;
            --bg-hover: #252525;
            --text-primary: rgba(255, 255, 255, 0.95);
            --text-secondary: rgba(255, 255, 255, 0.6);
            --text-tertiary: rgba(255, 255, 255, 0.4);
            --border: rgba(255, 255, 255, 0.1);
            --profit: #10B981;
            --loss: #EF4444;
            --warning: #F59E0B;
            --grid-unit: 8px;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            font-size: 14px;
            overflow-x: hidden;
        }

        .mono {
            font-family: 'JetBrains Mono', 'SF Mono', 'Monaco', monospace;
            font-variant-numeric: tabular-nums;
        }

        .container {
            max-width: 1920px;
            margin: 0 auto;
            padding: calc(var(--grid-unit) * 3);
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: calc(var(--grid-unit) * 3);
            border-bottom: 1px solid var(--border);
            padding-bottom: calc(var(--grid-unit) * 2);
        }

        .breadcrumb {
            color: var(--text-tertiary);
            font-size: 12px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: calc(var(--grid-unit) * 3);
        }

        .address-controls {
            display: flex;
            align-items: center;
            gap: calc(var(--grid-unit) * 1.5);
        }

        .address-input {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 6px 8px;
            font-size: 12px;
            width: 320px;
            outline: none;
        }

        .address-input::placeholder { color: var(--text-tertiary); }

        .address-btn {
            background: var(--bg-elevated);
            color: var(--text-secondary);
            border: 1px solid var(--border);
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
        }

        .address-btn:hover { color: var(--text-primary); border-color: var(--text-secondary); }

        .address {
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.15s;
        }

        .address:hover {
            color: var(--text-primary);
        }

        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            gap: calc(var(--grid-unit) * 4);
            margin-bottom: calc(var(--grid-unit) * 4);
            border-bottom: 1px solid var(--border);
        }

        .nav-tab {
            padding: calc(var(--grid-unit) * 1.5) 0;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-tertiary);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.15s;
            margin-bottom: -1px;
        }

        .nav-tab:hover {
            color: var(--text-secondary);
        }

        .nav-tab.active {
            color: var(--text-primary);
            border-bottom-color: var(--text-primary);
        }

        /* Tab Content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Key Metrics */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: calc(var(--grid-unit) * 2);
            margin-bottom: calc(var(--grid-unit) * 4);
        }

        .metric-card {
            background: var(--bg-secondary);
            padding: calc(var(--grid-unit) * 2.5);
            position: relative;
            border: 1px solid transparent;
            transition: border-color 0.15s;
        }

        .metric-card:hover {
            border-color: var(--border);
        }

        .metric-label {
            font-size: 11px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin-bottom: calc(var(--grid-unit) * 1);
        }

        .metric-value {
            font-size: 24px;
            font-weight: 500;
            line-height: 1;
            margin-bottom: calc(var(--grid-unit) * 0.5);
        }

        .metric-change {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .metric-sparkline {
            position: absolute;
            right: calc(var(--grid-unit) * 2);
            top: calc(var(--grid-unit) * 2);
            width: 50px;
            height: 20px;
            opacity: 0.3;
        }

        .profit { color: var(--profit); }
        .loss { color: var(--loss); }
        .warning { color: var(--warning); }

        /* Chart Area */
        .chart-container {
            background: var(--bg-secondary);
            padding: calc(var(--grid-unit) * 3);
            margin-bottom: calc(var(--grid-unit) * 4);
            height: 400px;
            position: relative;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: calc(var(--grid-unit) * 3);
        }

        .chart-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
        }

        .time-selector {
            display: flex;
            gap: calc(var(--grid-unit) * 2);
        }

        .time-option {
            padding: 4px 8px;
            font-size: 11px;
            color: var(--text-tertiary);
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid transparent;
        }

        .time-option:hover {
            color: var(--text-secondary);
        }

        .time-option.active {
            color: var(--text-primary);
            border-bottom: 1px solid var(--text-primary);
        }

        /* SVG Chart */
        .chart-svg {
            width: 100%;
            height: 320px;
        }

        .chart-line {
            fill: none;
            stroke: var(--text-primary);
            stroke-width: 2;
            opacity: 0.9;
        }

        .chart-area {
            fill: var(--text-primary);
            opacity: 0.05;
        }

        .chart-grid-line {
            stroke: var(--border);
            stroke-width: 1;
            opacity: 0.5;
        }

        /* Tables */
        .table-container {
            background: var(--bg-secondary);
            margin-bottom: calc(var(--grid-unit) * 4);
            overflow-x: auto;
        }

        .table-header {
            padding: calc(var(--grid-unit) * 2) calc(var(--grid-unit) * 3);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .table-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            text-align: right;
            padding: calc(var(--grid-unit) * 1.5) calc(var(--grid-unit) * 2);
            font-size: 10px;
            font-weight: 500;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        th:first-child,
        td:first-child {
            text-align: left;
            padding-left: calc(var(--grid-unit) * 3);
        }

        td {
            padding: calc(var(--grid-unit) * 1.5) calc(var(--grid-unit) * 2);
            text-align: right;
            font-size: 12px;
            border-top: 1px solid var(--border);
        }

        tr:hover td {
            background: var(--bg-elevated);
        }

        /* Grid Layouts */
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: calc(var(--grid-unit) * 3);
            margin-bottom: calc(var(--grid-unit) * 4);
        }

        .three-column {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: calc(var(--grid-unit) * 3);
            margin-bottom: calc(var(--grid-unit) * 4);
        }

        /* Risk Bar */
        .risk-bar {
            height: 3px;
            background: var(--bg-elevated);
            margin-top: calc(var(--grid-unit) * 1);
            position: relative;
        }

        .risk-bar-fill {
            height: 100%;
            background: var(--text-primary);
            opacity: 0.3;
            position: absolute;
            left: 0;
            top: 0;
        }

        .risk-bar-fill.danger {
            background: var(--loss);
            opacity: 0.6;
        }

        .risk-bar-fill.warning {
            background: var(--warning);
            opacity: 0.5;
        }

        /* Correlation Matrix */
        .correlation-matrix {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            margin-top: calc(var(--grid-unit) * 2);
        }

        .correlation-cell {
            aspect-ratio: 1;
            background: var(--bg-elevated);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: var(--text-secondary);
        }

        /* Heatmap */
        .heatmap {
            display: grid;
            grid-template-columns: repeat(24, 1fr);
            grid-template-rows: repeat(7, 1fr);
            gap: 2px;
            margin-top: calc(var(--grid-unit) * 3);
            height: 140px;
        }

        .heatmap-cell {
            background: var(--bg-elevated);
            transition: opacity 0.15s;
            cursor: pointer;
        }

        .heatmap-cell:hover {
            outline: 1px solid var(--text-primary);
            outline-offset: -1px;
        }

        /* Distribution Chart */
        .distribution-bars {
            display: flex;
            align-items: flex-end;
            height: 100px;
            gap: 2px;
            margin-top: calc(var(--grid-unit) * 2);
        }

        .distribution-bar {
            flex: 1;
            background: var(--text-primary);
            opacity: 0.2;
            min-height: 2px;
        }

        /* Command Palette Hint removed */

        /* Status Badge */
        .status-badge {
            display: inline-block;
            padding: 2px 6px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: var(--bg-elevated);
            color: var(--text-secondary);
        }

        .status-badge.live {
            background: var(--profit);
            color: var(--bg-primary);
        }

        /* Behavioral Score Cards */
        .behavior-card {
            background: var(--bg-secondary);
            padding: calc(var(--grid-unit) * 3);
            margin-bottom: calc(var(--grid-unit) * 2);
        }

        .behavior-score {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: calc(var(--grid-unit) * 2);
        }

        .score-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .score-value {
            font-size: 18px;
            font-weight: 500;
        }

        /* Mini Chart */
        .mini-chart {
            width: 100%;
            height: 60px;
            margin-top: calc(var(--grid-unit) * 2);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="breadcrumb" id="breadcrumb">dYdX Account Analytics</div>
            <div class="header-right">
                <span class="status-badge live">LIVE</span>
                <div class="address-controls">
                    <input id="addressInput" class="address-input mono" placeholder="Enter dYdX address (e.g., dydx1...)" />
                    <button id="addressLoadBtn" class="address-btn">Load</button>
                </div>
                <div class="address mono" id="addressDisplay">-</div>
            </div>
        </div>

        <!-- Navigation -->
        <div class="nav-tabs">
            <div class="nav-tab active" data-tab="overview">OVERVIEW</div>
            <div class="nav-tab" data-tab="performance">PERFORMANCE</div>
            <div class="nav-tab" data-tab="risk">RISK ANALYSIS</div>
            <div class="nav-tab" data-tab="positions">POSITIONS</div>
            <div class="nav-tab" data-tab="behavior">BEHAVIOR</div>
            <div class="nav-tab" data-tab="market">MARKET STRUCTURE</div>
        </div>

        <!-- Overview Tab -->
        <div class="tab-content active" id="overview">
            <!-- Primary Metrics -->
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">Total P&L</div>
                    <div class="metric-value mono" id="totalPnL">-</div>
                    <div class="metric-change mono" id="totalPnLChange">Loading...</div>
                    <svg class="metric-sparkline" viewBox="0 0 50 20">
                        <polyline points="0,15 10,12 20,10 30,8 40,5 50,3" fill="none" stroke="var(--profit)" stroke-width="1"/>
                    </svg>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Win Rate</div>
                    <div class="metric-value mono" id="winRate">-</div>
                    <div class="metric-change mono" id="winRateDetail">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label" id="profitFactorLabel">Profit Factor</div>
                    <div class="metric-value mono" id="profitFactor">-</div>
                    <div class="metric-change mono" id="profitFactorDetail">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Sharpe Ratio</div>
                    <div class="metric-value mono" id="sharpeRatio">-</div>
                    <div class="metric-change mono" id="sharpeMeta" title="">All time ⓘ</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Sortino Ratio</div>
                    <div class="metric-value mono" id="sortinoRatio">-</div>
                    <div class="metric-change mono" id="sortinoMeta" title="">All time ⓘ</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Max Drawdown</div>
                    <div class="metric-value mono" id="maxDrawdown">-</div>
                    <div class="metric-change mono" id="maxDrawdownDetail">-</div>
                </div>
            </div>

            

            <!-- P&L Chart -->
            <div class="chart-container">
                <div class="chart-header">
                    <div class="chart-title">Cumulative P&L with Drawdown Periods</div>
                    </div>
                <canvas id="pnlCumulativeChart" class="mini-chart" style="height: 260px"></canvas>
            </div>

            <!-- Quick Stats Grid -->
            <div class="two-column">
                <div class="table-container">
                    <div class="table-header">
                        <div class="table-title">Trading Statistics</div>
                    </div>
                    <table>
                        <tr>
                            <td style="color: var(--text-secondary)">Average Win</td>
                            <td class="mono profit" id="avgWin">-</td>
                        </tr>
                        <tr>
                            <td style="color: var(--text-secondary)">Average Loss</td>
                            <td class="mono loss" id="avgLoss">-</td>
                        </tr>
                        <tr>
                            <td style="color: var(--text-secondary)">Risk/Reward Ratio</td>
                            <td class="mono" id="riskReward">-</td>
                        </tr>
                        <tr>
                            <td style="color: var(--text-secondary)">Trade Expectancy</td>
                            <td class="mono profit" id="expectancy">-</td>
                        </tr>
                        <tr>
                            <td style="color: var(--text-secondary)" id="recoveryFactorLabel">Recovery Factor</td>
                            <td class="mono" id="recoveryFactor">-</td>
                        </tr>
                    </table>
                </div>

                <div class="table-container">
                    <div class="table-header">
                        <div class="table-title">Time Analysis</div>
                    </div>
                    <table>
                        <tr>
                            <td style="color: var(--text-secondary)">Avg Hold Time (Win)</td>
                            <td class="mono">4h 23m</td>
                        </tr>
                        <tr>
                            <td style="color: var(--text-secondary)">Avg Hold Time (Loss)</td>
                            <td class="mono">1h 47m</td>
                        </tr>
                        <tr>
                            <td style="color: var(--text-secondary)">Best Trading Hour</td>
                            <td class="mono">14:00 UTC</td>
                        </tr>
                        <tr>
                            <td style="color: var(--text-secondary)">Worst Trading Hour</td>
                            <td class="mono">03:00 UTC</td>
                        </tr>
                        <tr>
                            <td style="color: var(--text-secondary)">Most Active Day</td>
                            <td class="mono">Wednesday</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>

        <!-- Performance Tab -->
        <div class="tab-content" id="performance">
            <!-- Advanced Performance Metrics -->
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">Calmar Ratio</div>
                    <div class="metric-value mono" id="calmarRatio">-</div>
                    <div class="metric-change mono">Annual return / Max DD</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Kelly Criterion</div>
                    <div class="metric-value mono" id="kellyCriterion">-</div>
                    <div class="metric-change mono">Optimal size</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Max Consec. Wins</div>
                    <div class="metric-value mono" id="maxConsecWins">-</div>
                    <div class="metric-change mono profit" id="maxConsecWinsDetail"></div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Max Consec. Losses</div>
                    <div class="metric-value mono" id="maxConsecLosses">-</div>
                    <div class="metric-change mono loss" id="maxConsecLossesDetail"></div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Average RRR</div>
                    <div class="metric-value mono" id="avgRRR">-</div>
                    <div class="metric-change mono" id="avgRRRDetail">vs 2:1 target</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Win Rate Trend</div>
                    <div class="metric-value mono" id="winRateTrend">-</div>
                    <div class="metric-change mono" id="winRateTrendDetail">Last N trades</div>
                </div>
            </div>

            <!-- Win/Loss Distribution -->
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title" id="winLossTitle">Win/Loss Distribution</div>
                </div>
                <div class="distribution-bars" id="winLossDistribution"></div>
            </div>

            <!-- Monthly Performance -->
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">Monthly Performance Breakdown</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>MONTH</th>
                            <th>P&L</th>
                            <th>WIN RATE</th>
                            <th>TRADES</th>
                            <th>AVG WIN</th>
                            <th>AVG LOSS</th>
                            <th>PROFIT FACTOR</th>
                            <th>MAX DD</th>
                            <th>SHARPE</th>
                        </tr>
                    </thead>
                    <tbody id="monthlyPerformanceBody"></tbody>
                </table>
            </div>

            <!-- Asset Performance -->
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">Performance by Asset</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>ASSET</th>
                            <th>P&L</th>
                            <th>TRADES</th>
                            <th>WIN RATE</th>
                            <th>AVG P&L</th>
                            <th>BEST</th>
                            <th>WORST</th>
                            <th>SHARPE</th>
                        </tr>
                    </thead>
                    <tbody id="assetPerformanceBody"></tbody>
                </table>
            </div>
        </div>

        <!-- Risk Analysis Tab -->
        <div class="tab-content" id="risk">
            <!-- Risk Metrics -->
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">Value at Risk (95%)</div>
                    <div class="metric-value mono loss">-$3,847</div>
                    <div class="metric-change mono">Daily VaR</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Expected Shortfall</div>
                    <div class="metric-value mono loss">-$4,923</div>
                    <div class="metric-change mono">CVaR 95%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Beta to BTC</div>
                    <div class="metric-value mono">1.24</div>
                    <div class="metric-change mono">30-day rolling</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Beta to ETH</div>
                    <div class="metric-value mono">0.87</div>
                    <div class="metric-change mono">30-day rolling</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Leverage Utilization</div>
                    <div class="metric-value mono">3.2x</div>
                    <div class="risk-bar">
                        <div class="risk-bar-fill" style="width: 32%;"></div>
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Margin Call Risk</div>
                    <div class="metric-value mono warning">Medium</div>
                    <div class="risk-bar">
                        <div class="risk-bar-fill warning" style="width: 45%;"></div>
                    </div>
                </div>
            </div>

            <!-- Liquidation Analysis -->
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">Liquidation Risk Analysis</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>POSITION</th>
                            <th>SIZE</th>
                            <th>LEVERAGE</th>
                            <th>ENTRY</th>
                            <th>MARK</th>
                            <th>LIQ PRICE</th>
                            <th>DISTANCE</th>
                            <th>RISK SCORE</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>BTC-USD LONG</td>
                            <td class="mono">1.5</td>
                            <td class="mono">5x</td>
                            <td class="mono">67,420</td>
                            <td class="mono">69,183</td>
                            <td class="mono loss">58,947</td>
                            <td class="mono">14.8%</td>
                            <td class="mono warning">MEDIUM</td>
                        </tr>
                        <tr>
                            <td>ETH-USD LONG</td>
                            <td class="mono">12.0</td>
                            <td class="mono">4x</td>
                            <td class="mono">3,420</td>
                            <td class="mono">3,485</td>
                            <td class="mono loss">2,987</td>
                            <td class="mono">14.3%</td>
                            <td class="mono warning">MEDIUM</td>
                        </tr>
                        <tr>
                            <td>SOL-USD SHORT</td>
                            <td class="mono">250</td>
                            <td class="mono">3x</td>
                            <td class="mono">178.50</td>
                            <td class="mono">176.25</td>
                            <td class="mono loss">195.35</td>
                            <td class="mono">10.8%</td>
                            <td class="mono loss">HIGH</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Correlation Matrix -->
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">Position Correlation Matrix</div>
                </div>
                <div class="correlation-matrix">
                    <div class="correlation-cell">1.00</div>
                    <div class="correlation-cell">0.78</div>
                    <div class="correlation-cell">0.62</div>
                    <div class="correlation-cell">0.45</div>
                    <div class="correlation-cell">-0.23</div>
                    <div class="correlation-cell">0.78</div>
                    <div class="correlation-cell">1.00</div>
                    <div class="correlation-cell">0.71</div>
                    <div class="correlation-cell">0.53</div>
                    <div class="correlation-cell">-0.18</div>
                    <div class="correlation-cell">0.62</div>
                    <div class="correlation-cell">0.71</div>
                    <div class="correlation-cell">1.00</div>
                    <div class="correlation-cell">0.67</div>
                    <div class="correlation-cell">-0.31</div>
                    <div class="correlation-cell">0.45</div>
                    <div class="correlation-cell">0.53</div>
                    <div class="correlation-cell">0.67</div>
                    <div class="correlation-cell">1.00</div>
                    <div class="correlation-cell">-0.15</div>
                    <div class="correlation-cell">-0.23</div>
                    <div class="correlation-cell">-0.18</div>
                    <div class="correlation-cell">-0.31</div>
                    <div class="correlation-cell">-0.15</div>
                    <div class="correlation-cell">1.00</div>
                </div>
            </div>

            <!-- Historical Drawdowns -->
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">Historical Drawdown Periods</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>PERIOD</th>
                            <th>DEPTH</th>
                            <th>DURATION</th>
                            <th>RECOVERY</th>
                            <th>PEAK VALUE</th>
                            <th>TROUGH VALUE</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Mar 12-18, 2024</td>
                            <td class="mono loss">-18.7%</td>
                            <td class="mono">6 days</td>
                            <td class="mono">4 days</td>
                            <td class="mono">$45,000</td>
                            <td class="mono">$36,580</td>
                        </tr>
                        <tr>
                            <td>Feb 3-8, 2024</td>
                            <td class="mono loss">-11.2%</td>
                            <td class="mono">5 days</td>
                            <td class="mono">3 days</td>
                            <td class="mono">$32,100</td>
                            <td class="mono">$28,505</td>
                        </tr>
                        <tr>
                            <td>Jan 15-17, 2024</td>
                            <td class="mono loss">-6.7%</td>
                            <td class="mono">2 days</td>
                            <td class="mono">1 day</td>
                            <td class="mono">$18,470</td>
                            <td class="mono">$17,232</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Positions Tab -->
        <div class="tab-content" id="positions">
            <!-- Position Analytics -->
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">Active Positions</div>
                    <div class="metric-value mono" id="positionsActiveCount">-</div>
                    <div class="metric-change mono" id="positionsActiveNotional">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Avg Entry Efficiency</div>
                    <div class="metric-value mono" id="positionsEntryEfficiency">-</div>
                    <div class="metric-change mono">vs limit price</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Avg Exit Efficiency</div>
                    <div class="metric-value mono" id="positionsExitEfficiency">-</div>
                    <div class="metric-change mono">vs target</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Slippage Cost</div>
                    <div class="metric-value mono" id="positionsSlippageCost">-</div>
                    <div class="metric-change mono">MTD total</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Fill Rate</div>
                    <div class="metric-value mono" id="positionsFillRate">-</div>
                    <div class="metric-change mono">Limit orders</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">VWAP Performance</div>
                    <div class="metric-value mono" id="positionsVwapPerf">-</div>
                    <div class="metric-change mono">vs market VWAP</div>
                </div>
            </div>

            <!-- Recent Trades -->
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">Recent Position History</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>TIME</th>
                            <th>ASSET</th>
                            <th>SIDE</th>
                            <th>SIZE</th>
                            <th>ENTRY</th>
                            <th>EXIT</th>
                            <th>P&L</th>
                            <th>P&L %</th>
                            <th>DURATION</th>
                            <th>FUNDING</th>
                        </tr>
                    </thead>
                    <tbody id="positionsHistoryBody"></tbody>
                </table>
            </div>

            <!-- Hold Time Analysis -->
            <div class="two-column">
                <div class="table-container">
                    <div class="table-header">
                        <div class="table-title">Hold Time Distribution</div>
                    </div>
                    <div class="distribution-bars" id="holdTimeDistribution"></div>
                </div>

                <div class="table-container">
                    <div class="table-header">
                        <div class="table-title">Position Size Distribution</div>
                    </div>
                    <div class="distribution-bars" id="sizeDistribution"></div>
                </div>
            </div>
        </div>

        <!-- Behavior Tab -->
        <div class="tab-content" id="behavior">
            <!-- Behavioral Scores -->
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">Discipline Score</div>
                    <div class="metric-value mono">87/100</div>
                    <div class="metric-change mono profit">↑ 5 pts this week</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Stop Loss Adherence</div>
                    <div class="metric-value mono">92.3%</div>
                    <div class="metric-change mono">38/41 honored</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Revenge Trading</div>
                    <div class="metric-value mono warning">2</div>
                    <div class="metric-change mono">Instances this month</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">FOMO Entries</div>
                    <div class="metric-value mono warning">5</div>
                    <div class="metric-change mono loss">Cost: -$847</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Overtrading Score</div>
                    <div class="metric-value mono profit">Low</div>
                    <div class="metric-change mono">4.2 trades/day avg</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Scaling Efficiency</div>
                    <div class="metric-value mono">78.4%</div>
                    <div class="metric-change mono">In/out effectiveness</div>
                </div>
            </div>

            <!-- Pattern Recognition -->
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">Detected Trading Patterns</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>PATTERN</th>
                            <th>FREQUENCY</th>
                            <th>SUCCESS RATE</th>
                            <th>AVG P&L</th>
                            <th>RECOMMENDATION</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Morning Breakout (08:00-10:00)</td>
                            <td class="mono">47</td>
                            <td class="mono profit">74.5%</td>
                            <td class="mono profit">+$287</td>
                            <td style="color: var(--profit)">CONTINUE</td>
                        </tr>
                        <tr>
                            <td>Post-Loss Double Down</td>
                            <td class="mono">12</td>
                            <td class="mono loss">33.3%</td>
                            <td class="mono loss">-$423</td>
                            <td style="color: var(--loss)">AVOID</td>
                        </tr>
                        <tr>
                            <td>Friday Afternoon Trades</td>
                            <td class="mono">23</td>
                            <td class="mono loss">43.5%</td>
                            <td class="mono loss">-$127</td>
                            <td style="color: var(--warning)">REDUCE</td>
                        </tr>
                        <tr>
                            <td>Trend Following (>4h)</td>
                            <td class="mono">31</td>
                            <td class="mono profit">80.6%</td>
                            <td class="mono profit">+$512</td>
                            <td style="color: var(--profit)">INCREASE</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Trading Activity Heatmap -->
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">Trading Activity by Hour/Day</div>
                    <div class="mono" style="font-size: 11px; color: var(--text-tertiary);">INTENSITY MAP</div>
                </div>
                <div class="heatmap" id="activityHeatmap"></div>
            </div>
        </div>

        <!-- Market Structure Tab -->
        <div class="tab-content" id="market">
            <!-- Market Microstructure Metrics -->
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">Funding Captured</div>
                    <div class="metric-value mono profit" id="fundingCaptured">-</div>
                    <div class="metric-change mono">Last 30 days</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Funding Paid</div>
                    <div class="metric-value mono loss" id="fundingPaid">-</div>
                    <div class="metric-change mono">Last 30 days</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Net Funding</div>
                    <div class="metric-value mono" id="fundingNet">-</div>
                    <div class="metric-change mono" id="fundingNetPct">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Basis Arbitrage</div>
                    <div class="metric-value mono profit">+$847</div>
                    <div class="metric-change mono">4 opportunities</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Spread Captured</div>
                    <div class="metric-value mono">42.3%</div>
                    <div class="metric-change mono">Maker orders</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Book Imbalance Win</div>
                    <div class="metric-value mono">67.8%</div>
                    <div class="metric-change mono">At entry</div>
                </div>
            </div>

            <!-- Funding Rate Analysis -->
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">Funding Rate Analysis by Asset</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>ASSET</th>
                            <th>AVG RATE</th>
                            <th>CURRENT</th>
                            <th>PREDICTED</th>
                            <th>RECEIVED</th>
                            <th>PAID</th>
                            <th>NET</th>
                            <th>STATUS</th>
                        </tr>
                    </thead>
                    <tbody id="fundingAnalysisBody"></tbody>
                </table>
            </div>

            <!-- Order Book Analysis -->
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">Order Book Imbalance at Entry</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>IMBALANCE RANGE</th>
                            <th>TRADES</th>
                            <th>WIN RATE</th>
                            <th>AVG P&L</th>
                            <th>EFFECTIVENESS</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>>70% Buy</td>
                            <td class="mono">47</td>
                            <td class="mono profit">78.7%</td>
                            <td class="mono profit">+$342</td>
                            <td style="color: var(--profit)">HIGH</td>
                        </tr>
                        <tr>
                            <td>50-70% Buy</td>
                            <td class="mono">62</td>
                            <td class="mono">68.2%</td>
                            <td class="mono profit">+$187</td>
                            <td style="color: var(--profit)">GOOD</td>
                        </tr>
                        <tr>
                            <td>Balanced</td>
                            <td class="mono">124</td>
                            <td class="mono">52.4%</td>
                            <td class="mono profit">+$23</td>
                            <td style="color: var(--warning)">NEUTRAL</td>
                        </tr>
                        <tr>
                            <td>50-70% Sell</td>
                            <td class="mono">58</td>
                            <td class="mono">71.3%</td>
                            <td class="mono profit">+$214</td>
                            <td style="color: var(--profit)">GOOD</td>
                        </tr>
                        <tr>
                            <td>>70% Sell</td>
                            <td class="mono">41</td>
                            <td class="mono profit">75.6%</td>
                            <td class="mono profit">+$298</td>
                            <td style="color: var(--profit)">HIGH</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
    <script src="./risk-metrics.js"></script>
    <script>
        // Tab Navigation with persisted active tab
        function activateTab(tabId) {
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            const tabEl = document.querySelector(`.nav-tab[data-tab="${tabId}"]`);
            const contentEl = document.getElementById(tabId);
            if (tabEl && contentEl) {
                tabEl.classList.add('active');
                contentEl.classList.add('active');
                try { localStorage.setItem('activeTab', tabId); } catch(e) {}
                const bc = document.getElementById('breadcrumb');
                if (bc) bc.textContent = `dYdX Account Analytics / ${tabId.charAt(0).toUpperCase()}${tabId.slice(1)}`;
            }
        }
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                activateTab(this.dataset.tab);
            });
        });

        // Generate distribution bars (used for placeholders on non-Performance tabs only)
        function generateDistribution(containerId, count = 30) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            for (let i = 0; i < count; i++) {
                const bar = document.createElement('div');
                bar.className = 'distribution-bar';
                const height = Math.random() * 80 + 20;
                bar.style.height = `${height}%`;
                
                // Color based on value
                if (i < count * 0.3) {
                    bar.style.background = 'var(--loss)';
                    bar.style.opacity = '0.3';
                } else if (i > count * 0.7) {
                    bar.style.background = 'var(--profit)';
                    bar.style.opacity = '0.3';
                }
                
                container.appendChild(bar);
            }
        }

        // Generate heatmap
        function generateHeatmap(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            for (let i = 0; i < 168; i++) {
                const cell = document.createElement('div');
                cell.className = 'heatmap-cell';
                const intensity = Math.random();
                cell.style.backgroundColor = `rgba(255, 255, 255, ${intensity * 0.3})`;
                container.appendChild(cell);
            }
        }

        // Initialize visualizations (Performance tab distribution is rendered from real data later)
        generateDistribution('holdTimeDistribution', 24);
        generateDistribution('sizeDistribution', 20);
        generateHeatmap('activityHeatmap');

        // Time selector functionality
        document.querySelectorAll('.time-option').forEach(option => {
            option.addEventListener('click', function() {
                const parent = this.parentElement;
                parent.querySelectorAll('.time-option').forEach(o => o.classList.remove('active'));
                this.classList.add('active');
            });
        });

        // Address UI: load button and click-to-copy
        const addressLoadBtn = document.getElementById('addressLoadBtn');
        const addressInput = document.getElementById('addressInput');
        if (addressLoadBtn && addressInput) {
            addressLoadBtn.addEventListener('click', function() {
                const addr = (addressInput.value || '').trim();
                if (!addr) return;
                try { localStorage.setItem('lastAddress', addr); } catch (e) {}
                const url = new URL(window.location.href);
                url.searchParams.set('address', addr);
                window.location.href = url.toString();
            });
            addressInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') addressLoadBtn.click();
            });
        }

        // Click address: prompt to set if empty, otherwise copy
        document.querySelector('.address').addEventListener('click', function() {
            if (!currentAddress) {
                if (addressInput) addressInput.focus();
                return;
            }
            const toCopy = currentAddress;
            navigator.clipboard.writeText(toCopy);
            const original = this.textContent;
            this.textContent = 'Copied!';
            setTimeout(() => {
                this.textContent = original;
            }, 1500);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Command palette
            if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                e.preventDefault();
                alert('Command palette would open here');
            }
            
            // Tab navigation with number keys
            if (e.key >= '1' && e.key <= '6') {
                const tabIndex = parseInt(e.key) - 1;
                const tabs = document.querySelectorAll('.nav-tab');
                if (tabs[tabIndex]) {
                    tabs[tabIndex].click();
                }
            }
        });

        // dYdX API Configuration
        const DYDX_API = 'https://indexer.dydx.trade/v4';
        let currentAddress = null;
        let allData = {};

        // High-contrast defaults for Chart.js on dark background
        if (window.Chart) {
            Chart.defaults.color = 'rgba(255,255,255,0.98)';
            Chart.defaults.borderColor = 'rgba(255,255,255,0.12)';
            Chart.defaults.font.family = "'Inter', -apple-system, BlinkMacSystemFont, sans-serif";
            if (Chart.defaults.plugins && Chart.defaults.plugins.legend) {
                Chart.defaults.plugins.legend.labels = Chart.defaults.plugins.legend.labels || {};
                Chart.defaults.plugins.legend.labels.color = '#FFFFFF';
            }
        }

        // Fetch helpers with fallback across endpoint variants
        async function fetchJson(url) {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} for ${url}`);
            return res.json();
        }

        async function tryFetch(urls) {
            let lastError = null;
            for (const url of urls) {
                try {
                    return await fetchJson(url);
                } catch (e) {
                    lastError = e;
                    const msg = String(e && e.message || '');
                    if (msg.includes('HTTP 404')) {
                        console.debug('Variant 404, trying fallback:', url);
                    } else {
                        console.debug('Fallback trying', url, e);
                    }
                }
            }
            throw lastError || new Error('All endpoint variants failed');
        }

        // Format functions
        function formatCurrency(value) {
            if (value === null || value === undefined || isNaN(value)) return '-';
            const absValue = Math.abs(value);
            const sign = value >= 0 ? '+' : '-';
            
            if (absValue >= 1000000) {
                return sign + '$' + (absValue / 1000000).toFixed(2) + 'M';
            } else if (absValue >= 1000) {
                return sign + '$' + (absValue / 1000).toFixed(2) + 'K';
            } else {
                return sign + '$' + absValue.toFixed(2);
            }
        }

        function formatPercent(value) {
            if (value === null || value === undefined || isNaN(value)) return '-';
            return value.toFixed(1) + '%';
        }

        function computeMaxDrawdownPctFromEquity(equityArray) {
            if (!Array.isArray(equityArray) || equityArray.length === 0) return 0;
            let peak = -Infinity;
            let maxDrawdown = 0; // as negative fraction
            for (let i = 0; i < equityArray.length; i++) {
                const v = parseFloat(equityArray[i] || 0);
                if (!isFinite(v)) continue;
                if (v > peak) peak = v;
                if (peak > 0) {
                    const dd = (v - peak) / peak;
                    if (dd < maxDrawdown) maxDrawdown = dd;
                }
            }
            return Math.abs(maxDrawdown) * 100; // percentage as positive number
        }

        function computeMaxDrawdownFromEquity(equityArray) {
            if (!Array.isArray(equityArray) || equityArray.length === 0) return { pct: 0, abs: 0 };
            let peak = -Infinity;
            let peakVal = 0;
            let troughVal = 0;
            let maxDrawdown = 0; // negative fraction
            for (let i = 0; i < equityArray.length; i++) {
                const v = parseFloat(equityArray[i] || 0);
                if (!isFinite(v)) continue;
                if (v > peak) { peak = v; peakVal = v; }
                if (peak > 0) {
                    const dd = (v - peak) / peak; // <= 0
                    if (dd < maxDrawdown) { maxDrawdown = dd; troughVal = v; }
                }
            }
            const abs = Math.max(0, peakVal - troughVal);
            return { pct: Math.abs(maxDrawdown) * 100, abs };
        }

        // Build an equity curve adjusted to remove external cash flows (deposits/withdrawals)
        // Using identity: equity_t = equity_0 + totalPnl_t + netTransfers_t
        // Therefore, equity_no_transfers_t = equity_0 + totalPnl_t
        function computeAdjustedEquitySeriesFromHist(historicalPnl) {
            if (!Array.isArray(historicalPnl) || historicalPnl.length === 0) return [];
            const series = historicalPnl.slice().sort((a,b)=> (a.createdAt||'').localeCompare(b.createdAt||''));
            const eq0 = parseFloat(series[0].equity || 0) || 0;
            const pnl0 = parseFloat(series[0].totalPnl || 0) || 0;
            const eq0Adj = eq0 - pnl0;
            return series.map(p => {
                const pnl = parseFloat(p.totalPnl || 0) || 0;
                return eq0Adj + pnl;
            });
        }

        function computeAdjustedEquityPairsFromHist(historicalPnl) {
            if (!Array.isArray(historicalPnl) || historicalPnl.length === 0) return [];
            const series = historicalPnl.slice().sort((a,b)=> (a.createdAt||'').localeCompare(b.createdAt||''));
            const eq0 = parseFloat(series[0].equity || 0) || 0;
            const pnl0 = parseFloat(series[0].totalPnl || 0) || 0;
            const eq0Adj = eq0 - pnl0;
            return series.map(p => {
                const pnl = parseFloat(p.totalPnl || 0) || 0;
                return { t: p.createdAt, e: eq0Adj + pnl };
            });
        }

        // Load real dashboard data
        async function loadDashboard() {
            // Get address from URL params or stored input
            const urlParams = new URLSearchParams(window.location.search);
            let address = urlParams.get('address') || '';
            if (!address) {
                try { address = localStorage.getItem('lastAddress') || ''; } catch (e) { address = ''; }
            }
            
            const inputEl = document.getElementById('addressInput');
            const loadBtn = document.getElementById('addressLoadBtn');
            if (inputEl) inputEl.value = address;
            if (!address) return;

            currentAddress = address;

            // Update address display with shortened form
            const addressEl = document.getElementById('addressDisplay');
            if (addressEl) {
                const short = address.length > 12 ? `${address.slice(0, 8)}...${address.slice(-4)}` : address;
                addressEl.textContent = short;
                addressEl.title = address;
            }

            try {
                // Fetch data using only the variants confirmed to work against the live indexer
                const [subaccountData, openPositionsData, closedPositionsData, ordersData, fillsData, fundingPaymentsData, marketsData] = await Promise.all([
                    // Subaccount (path-style)
                    fetchJson(`${DYDX_API}/addresses/${address}/subaccountNumber/0`),
                    // Positions (query-style)
                    fetchJson(`${DYDX_API}/perpetualPositions?address=${address}&subaccountNumber=0&status=OPEN&limit=100`),
                    fetchJson(`${DYDX_API}/perpetualPositions?address=${address}&subaccountNumber=0&status=CLOSED&limit=100`),
                    // Orders/Fills/FundingPayments (query-style)
                    fetchJson(`${DYDX_API}/orders?address=${address}&subaccountNumber=0&limit=1000`),
                    fetchJson(`${DYDX_API}/fills?address=${address}&subaccountNumber=0&limit=1000`),
                    fetchJson(`${DYDX_API}/fundingPayments?address=${address}&subaccountNumber=0&limit=1000`),
                    // Markets
                    fetchJson(`${DYDX_API}/perpetualMarkets`)
                ]);

                allData = {
                    subaccount: subaccountData,
                    openPositions: openPositionsData,
                    closedPositions: closedPositionsData,
                    orders: ordersData,
                    fills: fillsData,
                    fundingPayments: fundingPaymentsData,
                    markets: marketsData
                };

                // Process and display data
                processData();
                try { localStorage.setItem('lastAddress', address); } catch (e) {}

            } catch (error) {
                console.error('Error loading dashboard:', error);
            }
        }

        // Helpers to normalize API shapes
        function extractPositions(container) {
            if (!container) return [];
            if (Array.isArray(container)) return container;
            if (Array.isArray(container.positions)) return container.positions;
            if (Array.isArray(container.perpetualPositions)) return container.perpetualPositions;
            if (Array.isArray(container.data)) return container.data;
            if (container.result && Array.isArray(container.result)) return container.result;
            return [];
        }

        function extractSubaccount(container) {
            if (!container) return null;
            if (container.subaccount) return container.subaccount;
            if (container.data && container.data.subaccount) return container.data.subaccount;
            // Some endpoints may return the subaccount fields at root
            if (container.equity !== undefined) return container;
            return null;
        }

        // Process real data
        function processData() {
            console.log('Processing data:', allData);
            
            // Get subaccount data
            const subaccount = extractSubaccount(allData.subaccount);
            
            // Get ALL positions (both open and closed)
            let allPositions = [];
            
            // Add open positions
            allPositions = allPositions.concat(extractPositions(allData.openPositions));

            // Add closed positions
            allPositions = allPositions.concat(extractPositions(allData.closedPositions));
            
            console.log('Open positions:', allData.openPositions?.positions?.length || 0);
            console.log('Closed positions:', allData.closedPositions?.positions?.length || 0);
            
            // Calculate P&L from positions and fills
            let totalUnrealizedPnL = 0;
            let totalRealizedPnL = 0;
            let openPositionCount = 0;
            
            // Calculate from positions
            allPositions.forEach(pos => {
                if (pos.status === 'OPEN') {
                    totalUnrealizedPnL += parseFloat(pos.unrealizedPnl || 0);
                    openPositionCount++;
                }
                totalRealizedPnL += parseFloat(pos.realizedPnl || 0);
            });
            
            // Calculate win/loss statistics from CLOSED positions
            let wins = 0;
            let losses = 0;
            let totalWinAmount = 0;
            let totalLossAmount = 0;
            
            // Process closed positions to calculate win/loss
            allPositions.forEach(pos => {
                if (pos.status === 'CLOSED') {
                    const realizedPnl = parseFloat(pos.realizedPnl || 0);
                    if (realizedPnl > 0) {
                        wins++;
                        totalWinAmount += realizedPnl;
                    } else if (realizedPnl < 0) {
                        losses++;
                        totalLossAmount += Math.abs(realizedPnl);
                    }
                }
            });
            
            console.log('Wins:', wins, 'Losses:', losses);
            console.log('Total win amount:', totalWinAmount, 'Total loss amount:', totalLossAmount);
            
            // Trading Activity by Market: CLOSED positions drive slice sizes; track OPEN counts for context
            const marketDistribution = {};
            const closedOnly = allPositions.filter(p => p.status === 'CLOSED');
            closedOnly.forEach(pos => {
                const market = pos.market || 'Unknown';
                if (!marketDistribution[market]) {
                    marketDistribution[market] = { tradeCount: 0, totalPnL: 0, openCount: 0 };
                }
                marketDistribution[market].tradeCount += 1;
                marketDistribution[market].totalPnL += parseFloat(pos.realizedPnl || 0);
            });
            const openOnly = allPositions.filter(p => p.status === 'OPEN');
            openOnly.forEach(pos => {
                const market = pos.market || 'Unknown';
                if (!marketDistribution[market]) {
                    marketDistribution[market] = { tradeCount: 0, totalPnL: 0, openCount: 0 };
                }
                marketDistribution[market].openCount += 1;
            });
            
            console.log('Market distribution:', marketDistribution);
            
            // Create Trading Activity Chart
            createMarketDistributionChart(marketDistribution);
            
            // Calculate total P&L
            const totalPnL = totalUnrealizedPnL + totalRealizedPnL;
            
            // Calculate derived metrics
            const totalTrades = wins + losses;
            const winRate = totalTrades > 0 ? (wins / totalTrades) * 100 : 0;
            const profitFactor = totalLossAmount > 0 ? totalWinAmount / totalLossAmount : 0;
            const avgWin = wins > 0 ? totalWinAmount / wins : 0;
            const avgLoss = losses > 0 ? totalLossAmount / losses : 0;

            // Update ALL metric cards with real data
            updateMetric('totalPnL', formatCurrency(totalPnL), totalPnL >= 0);
            document.getElementById('totalPnLChange').textContent = 'All Time';
            
            // Show win rate or N/A if no trades
            if (totalTrades > 0) {
                document.getElementById('winRate').textContent = formatPercent(winRate);
                document.getElementById('winRateDetail').textContent = `${wins} / ${totalTrades} trades`;
            } else {
                document.getElementById('winRate').textContent = 'N/A';
                document.getElementById('winRateDetail').textContent = 'No closed trades';
            }
            
            // Profit factor
            if (totalLossAmount > 0) {
                document.getElementById('profitFactor').textContent = profitFactor.toFixed(2);
                document.getElementById('profitFactorDetail').textContent = 
                    `${formatCurrency(totalWinAmount)} / ${formatCurrency(totalLossAmount)}`;
                const pfl = document.getElementById('profitFactorLabel');
                if (pfl) {
                    pfl.title = `Gross profit / gross loss\nGross profit: ${formatCurrency(totalWinAmount)}\nGross loss: ${formatCurrency(totalLossAmount)}`;
                }
            } else {
                document.getElementById('profitFactor').textContent = 'N/A';
                document.getElementById('profitFactorDetail').textContent = 'No losses recorded';
                const pfl = document.getElementById('profitFactorLabel');
                if (pfl) {
                    pfl.title = `Gross profit / gross loss\nNot defined when no losses are recorded`;
                }
            }

            // Max consecutive wins/losses from CLOSED positions sequence by time
            const closedSorted = allPositions
                .filter(p => p.status === 'CLOSED')
                .sort((a,b)=> new Date(a.closedAt) - new Date(b.closedAt));
            let maxW = 0, curW = 0, maxL = 0, curL = 0;
            let bestStreakPnL = 0, curStreakPnL = 0, worstStreakPnL = 0, curLossStreakPnL = 0;
            closedSorted.forEach(p => {
                const pnl = parseFloat(p.realizedPnl || 0);
                if (pnl > 0) {
                    curW += 1; maxW = Math.max(maxW, curW); curStreakPnL += pnl;
                    worstStreakPnL = Math.min(worstStreakPnL, curLossStreakPnL);
                    curL = 0; curLossStreakPnL = 0;
                } else if (pnl < 0) {
                    curL += 1; maxL = Math.max(maxL, curL); curLossStreakPnL += pnl; // pnl negative
                    bestStreakPnL = Math.max(bestStreakPnL, curStreakPnL);
                    curW = 0; curStreakPnL = 0;
                }
            });
            bestStreakPnL = Math.max(bestStreakPnL, curStreakPnL);
            worstStreakPnL = Math.min(worstStreakPnL, curLossStreakPnL);
            updateElement('maxConsecWins', String(maxW || 0));
            updateElement('maxConsecWinsDetail', bestStreakPnL ? `${formatCurrency(bestStreakPnL)}` : '');
            updateElement('maxConsecLosses', String(maxL || 0));
            updateElement('maxConsecLossesDetail', worstStreakPnL ? `${formatCurrency(worstStreakPnL)}` : '');
            
            // Compute all-time risk ratios from historical PnL endpoint using RiskMetrics helper
            (async () => {
                try {
                    const hist = await fetchJson(`${DYDX_API}/historical-pnl?address=${currentAddress}&subaccountNumber=0&limit=1000`);
                    // MAR from realized funding yield (Option C):
                    // per-period MAR = sum(payment) / sum(abs(size) * oraclePrice)
                    let marPerPeriod = 0;
                    const fp = (allData.fundingPayments && (allData.fundingPayments.fundingPayments || [])) || [];
                    if (fp.length > 0) {
                        let totalPayment = 0;
                        let totalNotional = 0;
                        fp.forEach(p => {
                            const pay = parseFloat(p.payment || 0);
                            const size = Math.abs(parseFloat(p.size || 0));
                            const price = parseFloat(p.oraclePrice || 0);
                            const notional = (isNaN(size) || isNaN(price)) ? 0 : size * price;
                            if (!isNaN(pay)) totalPayment += pay;
                            if (notional > 0) totalNotional += notional;
                        });
                        if (totalNotional > 0) marPerPeriod = totalPayment / totalNotional;
                    }
                    const res = window.RiskMetrics.computeAnnualizedFromHistoricalPnl(hist.historicalPnl, { mar: marPerPeriod, denominator: 'negative' });
                    if (res.returns.length > 2) {
                        document.getElementById('sharpeRatio').textContent = (res.sharpeAnnualized || 0).toFixed(2);
                        document.getElementById('sortinoRatio').textContent = (res.sortinoAnnualized === Infinity ? '∞' : (res.sortinoAnnualized || 0).toFixed(2));
                        // Tooltip/meta: show MAR, periods/year, and denominator
                        const ppy = res.ppy || 0;
                        const sharpeMeta = document.getElementById('sharpeMeta');
                        const sortinoMeta = document.getElementById('sortinoMeta');
                        const marPct = (marPerPeriod * (ppy || 1) * 100).toFixed(3);
                        const perText = ppy > 8000 ? 'hourly' : ppy > 300 ? 'daily' : 'periodic';
                        const tipSharpe = `MAR (${perText}, annualized): ${marPct}%\nPPY (periods/year): ${ppy.toFixed(0)}\nDenominator: standard deviation (σ)`;
                        const tipSortino = `MAR (${perText}, annualized): ${marPct}%\nPPY (periods/year): ${ppy.toFixed(0)}\nDenominator: downside deviation (negative-only LPSD)`;
                        if (sharpeMeta) sharpeMeta.title = tipSharpe;
                        if (sortinoMeta) sortinoMeta.title = tipSortino;

                        // Calmar ratio (annual return / max drawdown) using equity adjusted to exclude cash flows
                        const eq = computeAdjustedEquitySeriesFromHist(hist.historicalPnl || []);
                        if (eq.length > 1) {
                            const timestamps = (hist.historicalPnl || []).map(p => p.createdAt).filter(Boolean);
                            const rets = window.RiskMetrics.computeReturnsFromEquitySeries(eq);
                            const ann = window.RiskMetrics.computeAnnualizedFromReturns(rets, timestamps, { mar: 0, denominator: 'negative' });
                            // approximate annual return as mean per-period return * PPY
                            const mu = rets.length ? (rets.reduce((a,b)=>a+b,0) / rets.length) : 0;
                            const annualReturn = mu * (ann.ppy || 0);
                            const mddPct = computeMaxDrawdownPctFromEquity(eq) / 100; // fraction
                            const calmar = mddPct > 0 ? (annualReturn / mddPct) : null;
                            updateElement('calmarRatio', calmar === null ? 'N/A' : calmar.toFixed(2));
                        } else {
                            updateElement('calmarRatio','N/A');
                        }

                        // Fill Monthly/Asset tables metrics with historical equity context
                        updatePerformanceTables(allPositions, hist.historicalPnl || []);
                    } else {
            document.getElementById('sharpeRatio').textContent = 'N/A';
            document.getElementById('sortinoRatio').textContent = 'N/A';
                        updateElement('calmarRatio','N/A');
                        updatePerformanceTables(allPositions, []);
                    }
                } catch (e) {
                    // If endpoint not available, leave as N/A
                    document.getElementById('sharpeRatio').textContent = 'N/A';
                    document.getElementById('sortinoRatio').textContent = 'N/A';
                    updateElement('calmarRatio','N/A');
                    updatePerformanceTables(allPositions, []);
                }
            })();
            // Max DD from historical equity excluding cash flows
            (async () => {
                try {
                    const hist = await fetchJson(`${DYDX_API}/historical-pnl?address=${currentAddress}&subaccountNumber=0&limit=1000`);
                    const eqAdj = computeAdjustedEquitySeriesFromHist(hist.historicalPnl || []);
                    if (eqAdj.length > 1) {
                        const mdd = computeMaxDrawdownFromEquity(eqAdj);
                        updateElement('maxDrawdown', mdd.pct.toFixed(1) + '%');
                        updateElement('maxDrawdownDetail', `Peak-to-trough: ${formatCurrency(-mdd.abs)}`);
                    } else {
                        updateElement('maxDrawdown','N/A');
                        updateElement('maxDrawdownDetail','-');
                    }
                } catch (e) {
                    updateElement('maxDrawdown','N/A');
                    updateElement('maxDrawdownDetail','-');
                }
            })();

            // Update Trading Statistics section
            updateElement('avgWin', wins > 0 ? formatCurrency(avgWin) : 'N/A');
            updateElement('avgLoss', losses > 0 ? formatCurrency(avgLoss) : 'N/A');
            updateElement('riskReward', avgLoss > 0 ? `1:${(avgWin/avgLoss).toFixed(2)}` : 'N/A');
            updateElement('expectancy', totalTrades > 0 ? formatCurrency(totalPnL/totalTrades) : 'N/A');
            // Recovery Factor = Net Profit / Max Drawdown (absolute). Use adjusted equity curve for MDD.
            (async () => {
                try {
                    const hist = await fetchJson(`${DYDX_API}/historical-pnl?address=${currentAddress}&subaccountNumber=0&limit=1000`);
                    const eqAdj = computeAdjustedEquitySeriesFromHist(hist.historicalPnl || []);
                    if (eqAdj.length > 1) {
                        const mdd = computeMaxDrawdownFromEquity(eqAdj);
                        const netProfit = totalRealizedPnL + totalUnrealizedPnL; // same as totalPnL
                        const rf = mdd.abs > 0 ? (netProfit / mdd.abs) : null;
                        updateElement('recoveryFactor', rf===null ? 'N/A' : rf.toFixed(2));
                    } else {
            updateElement('recoveryFactor', 'N/A');
                    }
                } catch (e) {
                    updateElement('recoveryFactor', 'N/A');
                }
            })();
            
            // Update Positions tab from real data
            const fillsArr = (allData.fills && (allData.fills.fills || allData.fills.data || allData.fills)) || [];
            updatePositionsTabFromData(allPositions, fillsArr, subaccount);
            updatePerformanceMetrics(allPositions);
            // Performance tables will be filled after historical PnL fetch above

            // Kelly criterion from closed positions
            (function(){
                const closed = allPositions.filter(p=>p.status==='CLOSED');
                const N = closed.length;
                if(!N){ updateElement('kellyCriterion','N/A'); return; }
                const wins = closed.filter(p=>parseFloat(p.realizedPnl||0)>0);
                const losses = closed.filter(p=>parseFloat(p.realizedPnl||0)<0);
                const pWin = N? (wins.length/N) : 0;
                const avgWin = wins.length? wins.reduce((s,p)=>s+parseFloat(p.realizedPnl||0),0)/wins.length:0;
                const avgLossAbs = losses.length? Math.abs(losses.reduce((s,p)=>s+parseFloat(p.realizedPnl||0),0))/losses.length:0;
                const b = avgLossAbs>0? (avgWin/avgLossAbs) : 0; // win:loss payoff ratio
                const k = (b>0)? (pWin - (1-pWin)/b) : 0;
                updateElement('kellyCriterion', isFinite(k)? (k*100).toFixed(1)+'%' : 'N/A');
            })();

            // Funding metrics (Market Structure tab)
            const payments = (allData.fundingPayments && (allData.fundingPayments.fundingPayments || [])) || [];
            const cutoff = Date.now() - (30 * 24 * 3600 * 1000);
            let received = 0;
            let paid = 0;
            payments.forEach(p => {
                const ts = new Date(p.createdAt).getTime();
                if (isNaN(ts) || ts < cutoff) return;
                const amt = parseFloat(p.payment || 0);
                if (amt > 0) received += amt; else paid += Math.abs(amt);
            });
            const net = received - paid;
            updateElement('fundingCaptured', formatCurrency(received));
            updateElement('fundingPaid', formatCurrency(-paid));
            updateElement('fundingNet', formatCurrency(net));
            if (subaccount && subaccount.equity) {
                const pct = (net / parseFloat(subaccount.equity)) * 100;
                updateElement('fundingNetPct', `${pct.toFixed(2)}% of equity`);
            } else {
                updateElement('fundingNetPct', '-');
            }

            // Markets map and Funding analysis table
            const marketsMap = (allData.markets && (allData.markets.perpetualMarkets || allData.markets)) || {};
            updateFundingAnalysis(marketsMap, payments);
        }

        function updateMetric(id, value, isPositive = true) {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = value;
                el.className = isPositive ? 'metric-value mono profit' : 'metric-value mono loss';
            }
        }

        function updateElement(id, value) {
            const el = document.getElementById(id);
            if (el) el.textContent = value;
        }

        // Populate Positions tab from real data
        function updatePositionsTabFromData(positions, fills, subaccount) {
            const openPositions = positions.filter(p => p.status === 'OPEN');
            const activeCount = openPositions.length;
            const activeNotional = openPositions.reduce((sum, p) => {
                const size = parseFloat(p.size || 0);
                const entry = parseFloat(p.entryPrice || 0);
                return sum + (size * entry);
            }, 0);
            updateElement('positionsActiveCount', String(activeCount));
            updateElement('positionsActiveNotional', activeCount > 0 ? `$${activeNotional.toFixed(2)}` : '-');

            // Basic fill-based metrics (placeholders derived from fills; no fake constants)
            const totalFills = Array.isArray(fills) ? fills.length : 0;
            if (totalFills > 0) {
                // Approximate fill rate as ratio of MARKET orders to total when liquidity is TAKER (demo metric from real data)
                const takerFills = fills.filter(f => f.liquidity === 'TAKER').length;
                updateElement('positionsFillRate', ((takerFills / totalFills) * 100).toFixed(1) + '%');
            } else {
                updateElement('positionsFillRate', '-');
            }

            // Clear history body and rebuild from CLOSED positions
            const body = document.getElementById('positionsHistoryBody');
            if (!body) return;
            body.innerHTML = '';

            const closedPositions = positions
                .filter(p => p.status === 'CLOSED')
                .sort((a, b) => new Date(b.closedAt) - new Date(a.closedAt))
                .slice(0, 20);

            closedPositions.forEach(p => {
                const tr = document.createElement('tr');
                const created = new Date(p.createdAt);
                const closed = new Date(p.closedAt);
                const durationMs = closed - created;
                const hours = Math.floor(durationMs / 3600000);
                const minutes = Math.floor((durationMs % 3600000) / 60000);
                const durationText = (hours > 0 ? `${hours}h ` : '') + `${minutes}m`;
                const realized = parseFloat(p.realizedPnl || 0);
                const pct = (parseFloat(p.exitPrice || 0) && parseFloat(p.entryPrice || 0))
                    ? ((parseFloat(p.exitPrice) - parseFloat(p.entryPrice)) / parseFloat(p.entryPrice)) * (p.side === 'LONG' ? 100 : -100)
                    : 0;
                const funding = parseFloat(p.netFunding || 0);

                tr.innerHTML = `
                    <td class="mono">${closed.toLocaleString()}</td>
                    <td class="mono">${p.market || '-'}</td>
                    <td class="mono">${(p.side || '').toUpperCase()}</td>
                    <td class="mono">${(p.sumOpen || p.size || 0)}</td>
                    <td class="mono">${(p.entryPrice || '-')}</td>
                    <td class="mono">${(p.exitPrice || '-')}</td>
                    <td class="mono ${realized >= 0 ? 'profit' : 'loss'}">${formatCurrency(realized)}</td>
                    <td class="mono ${pct >= 0 ? 'profit' : 'loss'}">${pct.toFixed(2)}%</td>
                    <td class="mono">${durationText}</td>
                    <td class="mono ${funding >= 0 ? 'profit' : 'loss'}">${formatCurrency(funding)}</td>
                `;
                body.appendChild(tr);
            });
        }

        // Compute and update Performance tab metrics
        function updatePerformanceMetrics(positions) {
            const closed = positions.filter(p => p.status === 'CLOSED').sort((a,b)=> new Date(a.closedAt)-new Date(b.closedAt));
            // Max consecutive
            let maxW=0,curW=0,maxL=0,curL=0; let bestPnL=0,curBest=0,worstPnL=0,curWorst=0;
            closed.forEach(p=>{
                const pnl=parseFloat(p.realizedPnl||0);
                if(pnl>0){curW++;maxW=Math.max(maxW,curW);curBest+=pnl;worstPnL=Math.min(worstPnL,curWorst);curL=0;curWorst=0;}
                else if(pnl<0){curL++;maxL=Math.max(maxL,curL);curWorst+=pnl;bestPnL=Math.max(bestPnL,curBest);curW=0;curBest=0;}
            });
            bestPnL=Math.max(bestPnL,curBest); worstPnL=Math.min(worstPnL,curWorst);
            updateElement('maxConsecWins', String(maxW||0));
            updateElement('maxConsecWinsDetail', bestPnL? `${formatCurrency(bestPnL)}`:'');
            updateElement('maxConsecLosses', String(maxL||0));
            updateElement('maxConsecLossesDetail', worstPnL? `${formatCurrency(worstPnL)}`:'');

            // Average RRR from per-trade avg win/loss
            const wins=closed.filter(p=>parseFloat(p.realizedPnl||0)>0);
            const losses=closed.filter(p=>parseFloat(p.realizedPnl||0)<0);
            const avgWin = wins.length? wins.reduce((s,p)=>s+parseFloat(p.realizedPnl||0),0)/wins.length:0;
            const avgLoss = losses.length? Math.abs(losses.reduce((s,p)=>s+parseFloat(p.realizedPnl||0),0))/losses.length:0;
            const rrr = avgLoss>0? avgWin/avgLoss : null;
            if(rrr!=null){ updateElement('avgRRR', rrr.toFixed(2)+':1'); updateElement('avgRRRDetail','vs 2:1 target'); } else { updateElement('avgRRR','N/A'); }

            // Win rate trend (last N)
            const N= Math.min(50, closed.length);
            const last = closed.slice(-N);
            const wrt = last.length? (last.filter(p=>parseFloat(p.realizedPnl||0)>0).length/last.length)*100:0;
            const el = document.getElementById('winRateTrend'); if(el){ el.textContent = (wrt? ('↑ '+wrt.toFixed(1)+'%'):'-'); el.className = 'metric-value mono '+(wrt>=50?'profit':'loss'); }
            updateElement('winRateTrendDetail', last.length? `Last ${last.length} trades`:'');

            // Win/Loss Distribution bars from real trade returns
            const container = document.getElementById('winLossDistribution');
            if (container) {
                container.innerHTML = '';
                const returns = closed.map(p => {
                    const entry = parseFloat(p.entryPrice||0);
                    const exit = parseFloat(p.exitPrice||0);
                    const side = (p.side||'').toUpperCase();
                    if (!entry || !exit) return 0;
                    const r = (exit - entry) / entry * (side==='LONG'?1:-1);
                    return r; // fractional
                }).filter(v => isFinite(v));
                if (returns.length > 0) {
                    // Histogram into 21 bins from -20% to +20%
                    const bins = 21;
                    const minP = -0.2, maxP = 0.2;
                    const counts = new Array(bins).fill(0);
                    returns.forEach(r => {
                        const clamped = Math.max(minP, Math.min(maxP, r));
                        const idx = Math.min(bins-1, Math.max(0, Math.floor((clamped - minP) / (maxP - minP) * bins)));
                        counts[idx] += 1;
                    });
                    const maxC = Math.max(...counts);
                    counts.forEach((c, i) => {
                        const bar = document.createElement('div');
                        bar.className = 'distribution-bar';
                        const h = maxC>0 ? (c / maxC) * 100 : 0;
                        bar.style.height = `${Math.max(2, h)}%`;
                        // color left half loss, right half profit
                        const isLoss = (i < Math.floor(bins/2));
                        bar.style.background = isLoss ? 'var(--loss)' : 'var(--profit)';
                        bar.style.opacity = '0.4';
                        bar.title = `${((minP + (i+0.5)*(maxP-minP)/bins)*100).toFixed(1)}% bin: ${c}`;
                        container.appendChild(bar);
                    });
                    const title = document.getElementById('winLossTitle');
                    if (title) title.textContent = `Win/Loss Distribution (${returns.length} trades)`;
                } else {
                    const title = document.getElementById('winLossTitle');
                    if (title) title.textContent = 'Win/Loss Distribution (no data)';
                }
            }
        }

        // Build the Funding Analysis table from markets + funding payments
        function updateFundingAnalysis(marketsMap, fundingPayments) {
            const body = document.getElementById('fundingAnalysisBody');
            if (!body) return;
            body.innerHTML = '';

            // Aggregate received/paid by market
            const byMarket = {};
            const cutoff = Date.now() - (30 * 24 * 3600 * 1000);
            (fundingPayments || []).forEach(p => {
                const ts = new Date(p.createdAt).getTime();
                if (isNaN(ts) || ts < cutoff) return;
                const market = p.ticker || p.market || 'Unknown';
                const amt = parseFloat(p.payment || 0);
                if (!byMarket[market]) byMarket[market] = { received: 0, paid: 0, net: 0, count: 0 };
                if (amt > 0) byMarket[market].received += amt; else byMarket[market].paid += Math.abs(amt);
                byMarket[market].net += amt;
                byMarket[market].count += 1;
            });

            // Build rows for markets where there is any funding activity or a known market entry
            const entries = Object.keys(marketsMap || {}).map(ticker => {
                const m = marketsMap[ticker];
                const agg = byMarket[ticker] || { received: 0, paid: 0, net: 0, count: 0 };
                return {
                    ticker,
                    avgRate: null, // Could be computed from payments over notionals if needed
                    current: m?.nextFundingRate || '0',
                    predicted: m?.defaultFundingRate1H || '0',
                    received: agg.received,
                    paid: agg.paid,
                    net: agg.net,
                };
            });

            // Show only rows with activity or top few majors
            const filtered = entries
                .filter(e => Math.abs(e.net) > 0 || ['BTC-USD', 'ETH-USD', 'SOL-USD'].includes(e.ticker))
                .slice(0, 15);

            filtered.forEach(e => {
                const tr = document.createElement('tr');
                const status = e.net > 0 ? 'profit' : e.net < 0 ? 'loss' : '';
                const currPct = (parseFloat(e.current) || 0) * 100;
                const predPct = (parseFloat(e.predicted) || 0) * 100;
                tr.innerHTML = `
                    <td>${e.ticker}</td>
                    <td class="mono">${e.avgRate === null ? '-' : (e.avgRate * 100).toFixed(3) + '%'}</td>
                    <td class="mono ${currPct < 0 ? 'loss' : 'profit'}">${currPct.toFixed(3)}%</td>
                    <td class="mono">${predPct.toFixed(3)}%</td>
                    <td class="mono profit">${formatCurrency(e.received)}</td>
                    <td class="mono loss">${formatCurrency(-e.paid)}</td>
                    <td class="mono ${status}">${formatCurrency(e.net)}</td>
                    <td class="mono">${status ? status.toUpperCase() : '-'}</td>
                `;
                body.appendChild(tr);
            });
        }

        let marketChart = null;
        function createMarketDistributionChart(marketDistribution) {
            const ctx = document.getElementById('marketDistributionChart');
            if (!ctx) return;
            
            // Destroy existing chart if it exists
            if (marketChart) {
                marketChart.destroy();
            }
            
            // Sort markets by trade count and take top 5
            const sortedMarkets = Object.entries(marketDistribution)
                .sort((a, b) => b[1].tradeCount - a[1].tradeCount)
                .slice(0, 5);
            
            if (sortedMarkets.length === 0) {
                // No data to display
                return;
            }
            
            const labels = sortedMarkets.map(([market, data]) => {
                const openSuffix = data.openCount ? ` + ${data.openCount} open` : '';
                return `${market} (${data.tradeCount} closed${openSuffix})`;
            });
            const data = sortedMarkets.map(([_, data]) => data.tradeCount);
            const backgroundColors = [
                'rgba(16,185,129,0.9)',
                'rgba(59,130,246,0.9)',
                'rgba(245,158,11,0.9)',
                'rgba(239,68,68,0.9)',
                'rgba(139,92,246,0.9)'
            ];
            
            marketChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: 'rgba(0,0,0,0.6)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: 'rgba(255,255,255,0.98)',
                                padding: 16,
                                font: {
                                    size: 13,
                                    weight: '600'
                                },
                                boxWidth: 14,
                                boxHeight: 10,
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    const total = data.datasets[0].data.reduce((a, b) => a + b, 0);
                                    return data.labels.map((label, i) => {
                                        const value = data.datasets[0].data[i];
                                        const percentage = ((value / total) * 100).toFixed(1);
                                        return {
                                            text: `${label} — ${percentage}%`,
                                            fillStyle: data.datasets[0].backgroundColor[i],
                                            index: i
                                        };
                                    });
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(15,15,15,0.98)',
                            titleColor: 'rgba(255,255,255,0.98)',
                            bodyColor: 'rgba(255,255,255,0.96)',
                            borderColor: 'rgba(255,255,255,0.12)',
                            borderWidth: 1,
                            padding: 12,
                            callbacks: {
                                label: function(context) {
                                    const market = sortedMarkets[context.dataIndex];
                                    const md = market[1];
                                    const lines = [
                                        `Closed Positions: ${md.tradeCount}`
                                    ];
                                    if (md.openCount) lines.push(`Open Positions: ${md.openCount}`);
                                    lines.push(`Total P&L: ${formatCurrency(md.totalPnL)}`);
                                    return lines;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Build adjusted equity series (excluding cash flows) and draw with Chart.js, shading drawdown periods
        async function renderCumulativePnlChart(address) {
            const el = document.getElementById('pnlCumulativeChart');
            if (!el) return;
            try {
                const hist = await fetchJson(`${DYDX_API}/historical-pnl?address=${address}&subaccountNumber=0&limit=1000`);
                const pairs = computeAdjustedEquityPairsFromHist(hist.historicalPnl || []);
                if (pairs.length === 0) return;
                const labels = pairs.map(p => new Date(p.t));
                const equityAdj = pairs.map(p => p.e);
                // Drawdown computation (relative to running peak of adjusted equity)
                let peak = -Infinity;
                const drawdowns = equityAdj.map(v => {
                    peak = Math.max(peak, v);
                    return peak > 0 ? (v - peak) / peak : 0;
                });
                // Chart
                if (window.pnlChart) { window.pnlChart.destroy(); }
                window.pnlChart = new Chart(el.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [{
                            label: 'Equity (no cash flows)',
                            data: equityAdj,
                            borderColor: '#ffffff',
                            backgroundColor: 'rgba(255,255,255,0.05)',
                            fill: true,
                            pointRadius: 0,
                            tension: 0.2
                        },{
                            label: 'Drawdown (%)',
                            data: drawdowns.map(d => d * 100),
                            yAxisID: 'y1',
                            borderColor: 'rgba(239,68,68,0.7)',
                            backgroundColor: 'rgba(239,68,68,0.1)',
                            fill: true,
                            pointRadius: 0,
                            tension: 0.2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        scales: {
                            x: { type: 'time', time: { unit: 'day' }, ticks: { color: 'rgba(255,255,255,0.6)' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                            y: { ticks: { color: 'rgba(255,255,255,0.8)' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                            y1: { position: 'right', ticks: { color: 'rgba(239,68,68,0.9)' }, grid: { drawOnChartArea: false } }
                        },
                        plugins: { legend: { display: false } }
                    }
                });
            } catch (e) {
                console.warn('Failed to render PnL chart', e);
            }
        }

        // Populate Performance tables dynamically from positions; optionally use historical equity for Sharpe/MDD context
        function updatePerformanceTables(positions, historicalPnl = []) {
            // Monthly breakdown from CLOSED positions
            const monthly = {};
            positions.filter(p => p.status === 'CLOSED').forEach(p => {
                const d = new Date(p.closedAt || p.createdAt);
                if (isNaN(d)) return;
                const key = d.toLocaleString('en-US', { month: 'long', year: 'numeric' });
                if (!monthly[key]) monthly[key] = { pnl: 0, trades: 0, wins: 0, losses: 0, winSum: 0, lossSum: 0 };
                const pnl = parseFloat(p.realizedPnl || 0);
                monthly[key].pnl += pnl;
                monthly[key].trades += 1;
                if (pnl > 0) { monthly[key].wins += 1; monthly[key].winSum += pnl; }
                else if (pnl < 0) { monthly[key].losses += 1; monthly[key].lossSum += Math.abs(pnl); }
            });

            // For Sharpe/MDD per-month, build equity segments if historicalPnl is available
            const hist = Array.isArray(historicalPnl) ? historicalPnl.slice() : [];
            const byMonthEquity = {};
            if (hist.length > 2) {
                const pairs = computeAdjustedEquityPairsFromHist(hist);
                pairs.forEach(pt => {
                    const d = new Date(pt.t);
                    if (isNaN(d)) return;
                    const key = d.toLocaleString('en-US', { month: 'long', year: 'numeric' });
                    if (!byMonthEquity[key]) byMonthEquity[key] = [];
                    byMonthEquity[key].push({ t: pt.t, e: pt.e });
                });
            }
            const bodyM = document.getElementById('monthlyPerformanceBody');
            if (bodyM) {
                bodyM.innerHTML = '';
                Object.entries(monthly)
                    .sort((a,b)=> new Date(b[0]) - new Date(a[0]))
                    .forEach(([label, m]) => {
                        const tr = document.createElement('tr');
                        const winRate = m.trades ? (m.wins / m.trades) * 100 : 0;
                        const avgWin = m.wins ? m.winSum / m.wins : 0;
                        const avgLoss = m.losses ? m.lossSum / m.losses : 0;
                        const pf = m.lossSum > 0 ? (m.winSum / m.lossSum) : null;
                        // Sharpe/MDD per-month from equity segment
                        let sharpeTxt = '-';
                        let mddTxt = '-';
                        if (byMonthEquity[label] && byMonthEquity[label].length > 2) {
                            // Use adjusted equity without cash flows
                            const seg = byMonthEquity[label];
                            const eqSeg = seg.map(x => x.e);
                            const tsSeg = seg.map(x => x.t);
                            const rets = window.RiskMetrics.computeReturnsFromEquitySeries(eqSeg);
                            const ann = window.RiskMetrics.computeAnnualizedFromReturns(rets, tsSeg, { mar: 0, denominator: 'negative' });
                            const mddPct = computeMaxDrawdownPctFromEquity(eqSeg);
                            sharpeTxt = (ann.sharpeAnnualized || 0).toFixed(2);
                            mddTxt = mddPct.toFixed(1) + '%';
                        }
                        tr.innerHTML = `
                            <td>${label}</td>
                            <td class="mono ${m.pnl>=0?'profit':'loss'}">${formatCurrency(m.pnl)}</td>
                            <td class="mono">${winRate.toFixed(1)}%</td>
                            <td class="mono">${m.trades}</td>
                            <td class="mono ${avgWin>=0?'profit':'loss'}">${formatCurrency(avgWin)}</td>
                            <td class="mono ${avgLoss>=0?'profit':'loss'}">${formatCurrency(-avgLoss)}</td>
                            <td class="mono">${pf===null?'N/A':pf.toFixed(2)}</td>
                            <td class="mono">${mddTxt}</td>
                            <td class="mono">${sharpeTxt}</td>
                        `;
                        bodyM.appendChild(tr);
                    });
            }

            // Asset performance from ALL positions
            const byAsset = {};
            positions.forEach(p => {
                const m = p.market || 'Unknown';
                if (!byAsset[m]) byAsset[m] = { pnl: 0, trades: 0, wins: 0, losses: 0, winSum: 0, lossSum: 0 };
                const pnl = parseFloat(p.realizedPnl || 0) + parseFloat(p.unrealizedPnl || 0);
                byAsset[m].pnl += pnl;
                if (p.status === 'CLOSED') {
                    byAsset[m].trades += 1;
                    if (p.realizedPnl > 0) { byAsset[m].wins += 1; byAsset[m].winSum += parseFloat(p.realizedPnl); }
                    else if (p.realizedPnl < 0) { byAsset[m].losses += 1; byAsset[m].lossSum += Math.abs(parseFloat(p.realizedPnl)); }
                }
            });
            const bodyA = document.getElementById('assetPerformanceBody');
            if (bodyA) {
                bodyA.innerHTML = '';
                Object.entries(byAsset)
                    .filter(([ticker]) => byAsset[ticker].trades > 0)
                    .sort((a,b)=> Math.abs(b[1].pnl) - Math.abs(a[1].pnl))
                    .forEach(([ticker, a]) => {
                        const winRate = a.trades ? (a.wins / a.trades) * 100 : 0;
                        const avgPnL = a.trades ? (a.winSum - a.lossSum) / a.trades : 0;
                        const best = a.winSum > 0 ? a.winSum / Math.max(1,a.wins) : 0;
                        const worst = a.lossSum > 0 ? -a.lossSum / Math.max(1,a.losses) : 0;
                        // Asset Sharpe from equity filtered to periods with any exposure to this asset is non-trivial.
                        // As an approximation, compute per-trade Sharpe using closed trades returns for this asset.
                        let assetSharpeTxt = '-';
                        const assetClosed = positions.filter(p => p.status==='CLOSED' && (p.market||'Unknown')===ticker);
                        if (assetClosed.length > 2) {
                            const tradeReturns = assetClosed.map(p => {
                                const entry = parseFloat(p.entryPrice||0);
                                const exit = parseFloat(p.exitPrice||0);
                                const side = (p.side||'').toUpperCase();
                                if (!entry || !exit) return 0;
                                return ((exit - entry) / entry) * (side==='LONG'?1:-1);
                            }).filter(v=>isFinite(v));
                            const s = window.RiskMetrics.computeSharpe(tradeReturns, 0);
                            // not annualized across trades; display as raw
                            assetSharpeTxt = s.toFixed(2);
                        }
                        const tr = document.createElement('tr');
                        tr.innerHTML = `
                            <td>${ticker}</td>
                            <td class="mono ${a.pnl>=0?'profit':'loss'}">${formatCurrency(a.pnl)}</td>
                            <td class="mono">${a.trades}</td>
                            <td class="mono">${winRate.toFixed(1)}%</td>
                            <td class="mono ${avgPnL>=0?'profit':'loss'}">${formatCurrency(avgPnL)}</td>
                            <td class="mono ${best>=0?'profit':'loss'}">${formatCurrency(best)}</td>
                            <td class="mono ${worst>=0?'profit':'loss'}">${formatCurrency(worst)}</td>
                            <td class="mono">${assetSharpeTxt}</td>
                        `;
                        bodyA.appendChild(tr);
                    });
            }
        }
        // Auto-load real data on page load and restore last active tab
        window.addEventListener('load', async () => {
            try {
                const savedTab = localStorage.getItem('activeTab') || 'overview';
                activateTab(savedTab);
            } catch (e) {
                activateTab('overview');
            }
            await loadDashboard();
            // After dashboard loads, render the cumulative PnL chart from historical endpoint
            if (currentAddress) {
                renderCumulativePnlChart(currentAddress);
            }
        });
    </script>
</body>
